{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"clj-nix","text":"<p>Nix helpers for Clojure projects</p> <p>STATUS: alpha.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>The main goal of the project is to reduce the friction between Clojure and Nix. Nix is a great tool to build and deploy software, but Clojure is not well supported in the Nix ecosystem.</p> <p><code>clj-nix</code> tries to improve the situation, providing Nix helpers to interact with Clojure projects</p> <p>The main difficulty of packaging a Clojure application with Nix is that the derivation is restricted from performing any network request. But Clojure does network requests to resolve the dependency tree. Some network requests are done by Maven, since Clojure uses Maven under the hood. On the other hand, since git deps were introduced, Clojure also access the network to resolve the git dependencies.</p> <p>A common solution to this problem are lock files. A lock file is a snapshot of the entire dependency tree, usually generated the first time we install the dependencies. Subsequent installations will use the lock file to install exactly the same version of every dependency. Knowing beforehand all the dependencies, we can download and cache all of them, avoiding network requests during the build phase with Nix.</p> <p>Ideally, we could reuse a lock file generated by Maven or Clojure itself, but lock files are not popular in the JVM/Maven ecosystem. For that reason, <code>clj-nix</code> provides a way to create a lock file from a <code>deps.edn</code> file. Creating a lock file is a prerequisite to use the Nix helpers provided by <code>clj-nix</code></p> <p>GOALS:</p> <ul> <li>Create a binary from a clojure application</li> <li>Create an optimized JDK runtime to execute the clojure binary</li> <li>Create GraalVM native images from a clojure application</li> <li>Simplify container creation for a Clojure application</li> <li>Run any arbitrary clojure command at Nix build time (like <code>clj -T:build</code> or   <code>clj -M:test</code>)</li> </ul>"},{"location":"#similar-projects","title":"Similar projects","text":"<ul> <li>dwn</li> <li>clj2nix</li> <li>mvn2nix</li> <li>clojure-nix-locker</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#derivations","title":"Derivations","text":"<ul> <li>mkCljBin: Creates a clojure application</li> <li>customJdk: Creates a custom JDK with jlink. Optionally takes a   derivation created with <code>mkCljBin</code>. The intended use case is to create a   minimal JDK you can deploy in a container (e.g: a Docker image)</li> <li>mkGraalBin: Creates a binary with GraalVM from a derivation   created with <code>mkCljBin</code></li> <li>mkCljLib: Creates a clojure library jar</li> <li>mkBabashka: Builds custom   babashka</li> </ul> <p>Note</p> <p>Extra unknown attributes are passed to the <code>mkDerivation</code> function, see mkCljBin section for an example about how to add a custom check phase.</p>"},{"location":"api/#mkcljbin","title":"mkCljBin","text":"<p>Creates a Clojure application. Takes the following attributes (those without a default are mandatory, extra attributes are passed to mkDerivation):</p> <ul> <li> <p>jdkRunner: JDK used at runtime by the application. (Default: <code>jdk</code>)</p> </li> <li> <p>projectSrc: Project source code.</p> </li> <li> <p>name: Derivation and clojure project name. It's recommended to use a   namespaced name. If not, a namespace is added automatically. E.g. <code>foo</code> will   be transformed to <code>foo/foo</code></p> </li> <li> <p>version: Derivation and clojure project version. (Default: <code>DEV</code>)</p> </li> <li> <p>main-ns: Main clojure namespace. A <code>-main</code> function is expected here.   <code>main-ns</code> file must include the <code>:gen-class</code> directive, e.g.:   <code>(ns foo (:gen-class))</code>. That's required to generate a valid uberjar,   <code>clj-nix</code> does a check for it.</p> </li> <li> <p>buildCommand: Command to build the jar application. If not provided, a   default builder is used:   build.clj.   If you provide your own build command, you can define the path to the final   uberjar with the <code>jarPath</code> environment variable (e.g.:   <code>export jarPath=$BUILD_DIR/my_uber.jar</code>). If <code>jarPath</code> is undefined, <code>clj-nix</code>   will try to find a jar file in a directory called <code>target</code>.</p> </li> <li> <p>lockfile: The lock file. (Default: <code>${projectSrc}/deps-lock.json</code>)</p> </li> <li> <p>java-opts: List of Java options to include the application wrapper, e.g.:   <code>[ \"-Djava.awt.headless=true\" ]</code>. (Default: <code>[ ]</code>)</p> </li> <li> <p>compileCljOpts: Override options passed to   <code>compile-clj</code>.   (Default: <code>null</code>)</p> </li> <li> <p>javacOpts: Options passed to   <code>javac</code>.   Needed if the projects contains java source files. Only 2 options are   supoorted: <code>src-dirs</code> and <code>javac-opts</code>. (Default: <code>null</code>)</p> </li> <li> <p>uberOpts: Options passed to   <code>uber</code>   See TBUILD-11 for when you might need it.   Only 1 option is supported: <code>exclude</code>. (Default: <code>null</code>)</p> </li> <li> <p>enableLeiningen: Makes Leiningen accessible at build time (Default:   <code>false</code>)</p> </li> <li> <p>builder-extra-inputs: Extra inputs to the default builder (Default: <code>[ ]</code>)</p> </li> <li> <p>builder-java-opts List of Java options to include in default builder   command (Default: <code>[ ]</code>)</p> </li> <li> <p>builder-preBuild Pre build commands for the default builder (Default:   <code>\"\"</code>)</p> </li> <li>builder-postBuild Post build commands for the default builder (Default:   <code>\"\"</code>)</li> </ul> <p>Example:</p> <pre><code>mkCljBin {\n  jdkRunner = pkgs.jdk17_headless;\n  projectSrc = ./.;\n  name = \"me.lafuente/clj-tuto\";\n  version = \"1.0\";\n  main-ns = \"demo.core\";\n\n  buildCommand = \"clj -T:build uber\";\n\n  # mkDerivation attributes\n  doCheck = true;\n  checkPhase = \"clj -M:test\";\n}\n</code></pre> <p>Outputs:</p> <ul> <li>out: The application binary</li> <li>lib: The application jar</li> </ul>"},{"location":"api/#customjdk","title":"customJdk","text":"<p>Creates a custom JDK runtime. Takes the following attributes (those without a default are mandatory):</p> <ul> <li> <p>jdkBase: JDK used to build the custom JDK with jlink. (Default:   <code>nixpkgs.jdk17_headless</code>)</p> </li> <li> <p>cljDrv: Derivation generated with <code>mkCljBin</code>.</p> </li> <li> <p>name: Derivation name. (Default: <code>cljDrv.name</code>)</p> </li> <li> <p>version: Derivation version. (Default: <code>cljDrv.version</code>)</p> </li> <li> <p>java-opts: List of Java options to include the application wrapper, e.g.:   <code>[ \"-Djava.awt.headless=true\" ]</code>. (Default: <code>[ ]</code>)</p> </li> <li> <p>jdkModules: Option passed to jlink <code>--add-modules</code>. If null,   <code>jeps</code>   will be used to analyze the <code>cljDrv</code> and pick the necessary modules   automatically. (Default: <code>null</code>)</p> </li> <li> <p>extraJdkModules: Extra JDK modules appended to <code>jdkModules</code>. (Default:   <code>[ ]</code>)</p> </li> <li> <p>locales: Option passed to jlink <code>--include-locales</code>. (Default: <code>null</code>)</p> </li> </ul> <p>Example:</p> <pre><code>customJdk {\n  jdkBase = pkgs.jdk17_headless;\n  name = \"myApp\";\n  version = \"1.0.0\";\n  cljDrv = myCljBinDerivation;\n  locales = \"en,es\";\n}\n</code></pre> <p>Outputs:</p> <ul> <li>out: The application binary, using the custom JDK</li> <li>jdk: The custom JDK</li> </ul>"},{"location":"api/#mkgraalbin","title":"mkGraalBin","text":"<p>Generates a binary with GraalVM from an application created with <code>mkCljBin</code>. Takes the following attributes (those without a default are mandatory):</p> <ul> <li> <p>cljDrv: Derivation generated with <code>mkCljBin</code>.</p> </li> <li> <p>graalvm: GraalVM used at build time. (Default: <code>nixpkgs.graalvm-ce</code>)</p> </li> <li> <p>name: Derivation name. (Default: <code>cljDrv.name</code>)</p> </li> <li> <p>version: Derivation version. (Default: <code>cljDrv.version</code>)</p> </li> <li> <p>Options passed to nixpkgs   buildGraalvmNativeImage:   nativeBuildInputs, nativeImageBuildArgs,   extraNativeImageBuildArgs, graalvmXmx, meta. Empty options are   ignored.</p> </li> </ul> <p>Example:</p> <pre><code>mkGraalBin {\n  cljDrv = myCljBinDerivation;\n}\n</code></pre>"},{"location":"api/#mkcljlib","title":"mkCljLib","text":"<p>Creates a jar file for a Clojure library. Takes the following attributes (those without a default are mandatory, extra attributes are passed to mkDerivation):</p> <ul> <li> <p>projectSrc: Project source code.</p> </li> <li> <p>name: Derivation and clojure library name. It's recommended to use a   namespaced name. If not, a namespace is added automatically. E.g. <code>foo</code> will   be transformed to <code>foo/foo</code></p> </li> <li> <p>version: Derivation and clojure project version. (Default: <code>DEV</code>)</p> </li> <li> <p>buildCommand: Command to build the jar application. If not provided, a   default builder is used:   jar fn in build.clj.   If you provide your own build command, clj-nix expects that a jar will be   generated in a directory called <code>target</code></p> </li> </ul> <p>Example:</p> <pre><code>mkCljLib {\n  projectSrc = ./.;\n  name = \"me.lafuente/my-lib\";\n  buildCommand = \"clj -T:build jar\";\n}\n</code></pre>"},{"location":"api/#mkbabashka","title":"mkBabashka","text":"<p>Builds Babashka with the specified features. See babashka feature flags for the full list. Notice that the feature names in the Nix wrapper are case insensitive and we can omit the <code>BABASHKA_FEATURE_</code> prefix.</p> <p>Takes the following attributes:</p> <ul> <li> <p>withFeatures: List of extra Babashka features. (Default: <code>[]</code>)</p> </li> <li> <p>bbLean: Disable default Babashka features. (Default: <code>false</code>)</p> </li> <li> <p>graalvm: GraalVM used at build time. (Default: <code>nixpkgs.graalvm-ce</code>)</p> </li> <li> <p>wrap: Create a wrapper with <code>rlwrap</code> (Default: <code>true</code>)</p> </li> </ul> <p>Example:</p> <pre><code>mkBabashka {\n  withFeatures = [ \"jdbc\" \"sqlite\" ];\n}\n</code></pre>"},{"location":"api/#helpers","title":"Helpers","text":"<ul> <li>mkCljCli: Takes a derivation created with <code>customJdk</code> and returns   a valid command to launch the application, as a string. Useful when creating a   container.</li> <li>bbTasksFromFile: Helper to wrap all the clojure functions   in a file as bash scripts. Useful to create a nix develpment shell with   devshell</li> <li>mk-deps-cache: Creates a Clojure deps cache (maven cache +   gitlibs cache). Used by <code>mkCljBin</code> and <code>mkCljLib</code>. You can use this function   to to have access to the cache in a nix derivation.</li> </ul>"},{"location":"api/#mkcljcli","title":"mkCljCli","text":"<p>Returns a string with the command to launch an application created with <code>customJdk</code>. Takes the following attributes (those without a default are mandatory):</p> <p>jdkDrv: Derivation generated with <code>customJdk</code></p> <p>java-opts: Extra arguments for the Java command (Default: <code>[]</code>)</p> <p>extra-args: Extra arguments for the Clojure application (Default: <code>\"\"</code>)</p> <p>Example:</p> <pre><code>mkCljCli {\n  jdkDrv = self.packages.\"${system}\".jdk-tuto;\n  java-opts = [ \"-Dclojure.compiler.direct-linking=true\" ];\n  extra-args = [ \"--foo bar\" ];\n}\n</code></pre>"},{"location":"api/#bbtasksfromfile","title":"bbTasksFromFile","text":"<p>Reads a Clojure file, for each function generates a devshell command. Takes a path (to a Clojure file) or the following attributes:</p> <p>file: Path to the Clojure file</p> <p>bb: Babashka derivation (Default: <code>nixpkgs.babashka</code>)</p> <p>Example:</p> <pre><code>devShells.default =\n  pkgs.devshell.mkShell {\n    commands = pkgs.bbTasksFromFile ./tasks.clj;\n    # or\n    commands = pkgs.bbTasksFromFile {\n      file = ./tasks.clj;\n      bb = pkgs.mkBabashka { withFeatures = [ \"jdbc\" \"sqlite\" ]; };\n    };\n  }\n</code></pre>"},{"location":"api/#mk-deps-cache","title":"mk-deps-cache","text":"<p>Generate maven + gitlib cache from a lock file. This is a lower level helper, usually you want to use <code>mkCljBin</code> or <code>mkCljLib</code> and define a custom build command with the <code>buildCommand</code> argument.</p> <p>lockfile: deps-lock.json file</p> <p>Example:</p> <pre><code>mk-deps-cache {\n  lockfile = ./deps-lock.json;\n}\n</code></pre>"},{"location":"bb-env/","title":"Babashka Builder","text":""},{"location":"bb-env/#nix-babashka-builder","title":"Nix Babashka builder","text":"<p>This a very experimental Nix builder that uses Babashka as an alternative builder for Nix (Nixpkgs is build on top of <code>stdenv.mkDerivation</code>, which is developed with Bash)</p> <p>All the examples in this document can be found here:</p> <p>https://github.com/jlesquembre/bb-pkgs</p>"},{"location":"bb-env/#installation","title":"Installation","text":"<p>Add the following to your <code>flake.nix</code> inputs:</p> <pre><code>clj-nix.url = \"github:jlesquembre/clj-nix\";\n</code></pre> <p>The flake provides a helper function, <code>babashkaEnv</code>, which returns a function that we can use to create derivations. This function is basically a replacement for <code>stdenv.mkDerivation</code>. We recommend naming the function you create with <code>babashkaEnv</code> as <code>mkBabashkaDerivation</code>.</p> <p>For a working example see:</p> <p>https://github.com/jlesquembre/bb-pkgs/blob/main/flake.nix</p>"},{"location":"bb-env/#structure","title":"Structure","text":"<p>When creating derivations with <code>mkBabashkaDerivation</code>, a specific directory structure is expected. Each derivation must live in its own directory (which you usually want to name the same as your package), and the directory must contain at least one file called <code>package.clj</code>. Under the same directory, you can put any other files required by the derivation.</p> <p>For example, with two derivations, the file structure would look like this:</p> <pre><code>pkgs\n\u251c\u2500\u2500 caddy\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 package.clj\n\u2514\u2500\u2500 nginx\n    \u2514\u2500\u2500 package.clj\n</code></pre>"},{"location":"bb-env/#usage","title":"Usage","text":"<p>Let's see an example of a <code>package.clj</code> file:</p> <pre><code>(ns hello.package\n\n(def version \"2.12.1\");\n\n(defn version-url\n  [v]\n  (format \"mirror://gnu/hello/hello-%s.tar.gz\" v))\n\n(def pkg\n  {:name \"hello\"\n   :version version\n   :deps []\n   :build-deps [:gcc]\n   :src {:fetcher :fetchurl\n         :url (version-url version)\n         :hash \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\"}\n   :build (fn [_args] \"Build something...\")})\n</code></pre> <p>For a full working example, see:</p> <p>https://github.com/jlesquembre/bb-pkgs/blob/main/pkgs/hello/package.clj</p> <p>To create a derivation, the <code>package.clj</code> must:</p> <ul> <li>Define a namespace, e.g.: <code>(ns foo.package)</code></li> <li> <p>Create a var called <code>pkg</code>. It must be a hash map with, at least, 3 keys,   <code>:name</code>, <code>:version</code>, and <code>:build</code>. Optionally, you can also define <code>:deps</code>,   <code>:build-deps</code> and <code>:src</code>.</p> </li> <li> <p><code>:name</code>: The name of the derivation. (It can be any name.)</p> </li> <li> <p><code>:version</code>: The version of the derivation. (It can be any alphanumeric     string.)</p> </li> <li> <p><code>:deps</code>: The runtime dependencies. (A list of strings or keywords. The name     should be a valid derivation name on     nixpkgs</p> </li> <li> <p><code>:build-deps</code>: Similar to <code>:deps</code>, but for dependecies only needed at build     time.</p> </li> <li> <p><code>:src</code>: The source to build the derivation, similar to the src attribute of     mkDerivation. See the next section for more details.</p> </li> <li> <p><code>:build</code>: A function that builds the derivation. See the details in the next     section.</p> </li> </ul>"},{"location":"bb-env/#src","title":"<code>:src</code>","text":"<p>This is similar to the <code>src</code> attribute of <code>mkDerivation</code>. It must be a hash map with only one key present: <code>fetcher</code>. The <code>fetcher</code> key should contain the name of one of the nixpkgs fetchers. All other arguments defined are passed directly to the fetcher.</p>"},{"location":"bb-env/#build","title":"<code>:build</code>","text":"<p>The build function takes one argument, a hash map. Most of the values in this hash map are environment variables set by <code>stdenv.mkDerivation</code>. Here are the most important ones:</p> <ul> <li><code>src</code>: The path to the temporary build directory where the source has been   copied and unpacked (if needed).</li> <li><code>out</code>: The path to the Nix store where you can copy files. A derivation must,   at a minimum, create this directory.</li> </ul>"},{"location":"bb-env/#dependecies","title":"Dependecies","text":"<p>If you want to add a dependency created with <code>mkBabashkaDerivation</code> (instead of a Nixpkgs dependency), namespace your dependency with <code>:bb</code>, e.g.: <code>[:bash :bb/my-pkg]</code>. Here, <code>bash</code> is provided by Nixpkgs, while <code>bb/my-pkg</code> is a derivation created with <code>mkBabashkaDerivation</code>. For that to work, you need to define the <code>bb-pkgs</code> argument to <code>babashkaEnv</code>, e.g.:</p> <pre><code>outputs = { self, nixpkgs, clj-nix, ... }@inputs:\n\n  let\n    supportedSystems = [ \"aarch64-darwin\" \"aarch64-linux\" \"x86_64-darwin\" \"x86_64-linux\" ];\n\n    eachSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {\n      pkgs = import nixpkgs { inherit system; };\n      inherit system;\n    });\n  in\n  {\n    packages = eachSystem ({ pkgs, system }:\n      let\n        mkBabashkaDerivation = clj-nix.outputs.packages.${system}.babashkaEnv {\n          inherit system pkgs;\n          bb-pkgs = self.outputs.packages.${system};\n        };\n      in\n      {\n        hello = mkBabashkaDerivation { pkg = ./pkgs/hello; };\n        simple = mkBabashkaDerivation { pkg = ./pkgs/simple; };\n      });\n  };\n</code></pre>"},{"location":"bb-env/#overrides","title":"Overrides","text":"<p>It is also posible to override a derivation. To do that, the <code>mkBabashkaDerivation</code> accepts a second argument, <code>override</code>:</p> <pre><code>mkBabashkaDerivation {\n  pkg = ./pkgs/hello;\n  override = ./pkgs/hello_override;\n}\n</code></pre> <p>In the directory of your override, create a file called <code>override.clj</code>. In that file, you must define a function called <code>override</code>. It takes only one argument, the <code>pkg</code> defined in the derivation, and it must return a modified version of it. E.g.:</p> <pre><code>(ns hello-override.override\n  (:require [hello.package :as hello]))\n\n(def version \"2.10\")\n\n(defn override\n  [pkg]\n  (-&gt; pkg\n      (assoc :version version)\n      (assoc-in [:src :url] (hello/version-url version))\n      (assoc-in [:src :hash] \"sha256-MeBmE3qWJnbon2nRtlOC3pWn732RS4y5VvQepy4PUWs=\")))\n</code></pre>"},{"location":"bb-env/#similar-project","title":"Similar project","text":"<p>A non-exhaustive list of projects providing alternative Nix builders:</p> <ul> <li>nuenv: A Nushell environment for Nix</li> <li>nix-reinventing-the-wheel</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":""},{"location":"faq/#how-can-i-define-extra-runtime-dependencies","title":"How can I define extra runtime dependencies?","text":"<p>If you try to call a external program from your Clojure application, you will get an error (something like <code>Cannot run program \"some-program\": error=2, No such file or directory</code>). One possible solution is to wrap the binary:</p> <pre><code>cljpkgs.mkCljBin {\n# ...\nnativeBuildInputs = [ pkgs.makeWrapper ];\npostInstall = ''\n  wrapProgram $binaryPath \\\n    --set PATH ${pkgs.lib.makeBinPath [ pkgs.cowsay ]}\n'';\n}\n</code></pre> <p>Notice that the <code>$binaryPath</code> is a proper Bash variable. It is created by <code>mkCljBin</code> during the install phase.</p> <p>or if you want to define the dependencies in a docker image:</p> <pre><code>pkgs.dockerTools.buildLayeredImage {\n  # ...\n  config = {\n    Env = [ \"PATH=${pkgs.lib.makeBinPath [ pkgs.cowsay ]}\" ];\n  };\n};\n</code></pre>"},{"location":"faq/#my-customjdk-application-has-an-ssl-handshake_failure","title":"My customJdk application has an SSL handshake_failure","text":"<p>If after creating an application using the <code>customJdk</code> package, you might see an error like the following:</p> <pre><code>javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\n</code></pre> <p>This could be caused by a missing jdkModule, such as <code>jdk.crypto.ec</code>, which is required for many <code>https</code> connections. Add the missing modules explicitly.</p> <pre><code>custom-jdk = pkgs.clj-nix.customJdk {\n  cljDrv = clj;\n  jdkBase = pkgs.jdk17_headless;\n  # locales = \"en\";\n  javaOpts = [];\n  extraJdkModules = [\"java.security.jgss\" \"java.security.sasl\" \"jdk.crypto.ec\"];\n};\n</code></pre>"},{"location":"github-action/","title":"GitHub Actions","text":""},{"location":"github-action/#github-action","title":"Github action","text":"<p>It's possible to add a GitHub action to automatically update the <code>deps-lock.json</code> file on changes:</p> <pre><code>name: \"Update deps-lock.json\"\non:\n  push:\n    paths:\n      - \"**/deps.edn\"\n\njobs:\n  update-lock:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: cachix/install-nix-action@v17\n\n      - name: Update deps-lock\n        run: \"nix run github:jlesquembre/clj-nix#deps-lock\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.0.3\n        with:\n          commit-message: Update deps-lock.json\n          title: Update deps-lock.json\n          branch: update-deps-lock\n</code></pre>"},{"location":"lock-file/","title":"Lock files","text":""},{"location":"lock-file/#generate-lock-file","title":"Generate lock file","text":"<p>As mentioned, a lock file must be generated in advance:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock\n</code></pre> <p>That command looks for <code>deps.edn</code> files in your project and generates a <code>deps-lock.json</code> file in the current directory. Remember to re-run it if you update your dependencies.</p> <p>By default all dependencies in all <code>deps.edn</code> files are included. It is possible to exclude certain <code>deps.edn</code> files and/or aliases. To see the full list of options of <code>deps-lock</code> run:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock -- --help\n</code></pre> <p>It is possible to add the dependencies to the nix store during the lock file generation. Internally we are invoking the <code>nix store add-path</code> command. By default, it's disabled because that command is relatively slow. To add the dependencies to the nix store, set the environment variable <code>CLJNIX_ADD_NIX_STORE</code> to true, e.g.:</p> <pre><code>CLJNIX_ADD_NIX_STORE=true nix run github:jlesquembre/clj-nix#deps-lock\n</code></pre>"},{"location":"lock-file/#ignore-depsedn-files","title":"Ignore deps.edn files","text":"<p>Sometimes it could be useful to ignore some <code>deps.edn</code> files, to do that, just pass the list of files to ignore the the <code>deps-lock</code> command:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock -- --deps-exclude ignore/deps.edn\n</code></pre> <p>There is also a <code>--deps-include</code> option, to include only certain files.</p>"},{"location":"lock-file/#ignore-aliases","title":"Ignore aliases","text":"<p>To exclude the dependencies defined in some aliases use the <code>--alias-exclude</code> option:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock -- --alias-exclude test\n</code></pre> <p>There is also a <code>--alias-include</code> option, to include only certain aliases.</p>"},{"location":"lock-file/#git-dependencies-in-privatessh-repositories","title":"Git dependencies in private/ssh repositories","text":"<p>In order to use the nix builtin fetcher on a git dependency, add a key-value <code>:clj-nix.git/fetch :builtins.fetchTree</code> to the dependency in <code>deps.edn</code>, e.g.</p> <pre><code>{:deps {private/dependency {:git/url \"git@private.host:secret/repo.git\"\n                            :git/sha \"0000000000000000000000000000000000000000\"\n                            :clj-nix.git/fetch :builtins.fetchTree}}}\n</code></pre> <p>This should work well in many cases where a repository can be accessed with the help of ssh-agent or other credential mechanisms, that nix builtin fetch supports.</p> <p>The trade-off (and reason that's not the default) is, that the dependency will be fetched at evaluation time, causing downloads even during <code>--dry-run</code>; Pending resolution of an issue in nix.</p>"},{"location":"lock-file/#babashka-dependencies","title":"Babashka dependencies","text":"<p>Dependencies on <code>bb.edn</code> files can be added to the <code>deps-lock.json</code> file:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock -- --bb\n</code></pre>"},{"location":"lock-file/#leiningen","title":"Leiningen","text":"<p>Leiningen projects are supported. Use the <code>--lein</code> option to add the <code>project.clj</code> dependencies to the lock file. This option can be combined with ignored files:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock -- --lein\n</code></pre> <p>By default, all custom profiles (if any) are merged to download the dependencies.  This can be customized with the <code>--lein-profiles</code> option.</p> <p>Keep in mind that <code>deps-lock</code> command is not optimized for Leiningen projects, it will download all the maven dependencies every time we generate the lock file. For that reason, it is recommended to add a <code>deps.edn</code> file with the same dependencies to Leiningen projects. That way, we reduce the number of network requests when the <code>deps-lock</code> command is invoked.</p> <p>There are projects to automatically generate a <code>deps.edn</code> file from a Leiningen project (e.g.: depify)</p> <p>Warning</p> <p>Leiningen projects must define a <code>buildCommand</code> in the <code>mkCljBin</code> function. The default build command assumes a <code>deps.edn</code> project.</p>"},{"location":"nix-module/","title":"Nix Module","text":""},{"location":"nix-module/#example","title":"Example","text":"<p>Minimal example, add a <code>flake.nix</code> with something like this:</p> flake.nix<pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n    clj-nix.url = \"github:jlesquembre/clj-nix\";\n  };\n  outputs = { self, nixpkgs, flake-utils, clj-nix }:\n\n    flake-utils.lib.eachDefaultSystem (system: {\n      packages = {\n\n        default = clj-nix.lib.mkCljApp {\n          pkgs = nixpkgs.legacyPackages.${system};\n          modules = [\n            {\n              projectSrc = ./.;\n              name = \"my.org/clj-project\";\n              version = \"1.0\";\n              main-ns = \"demo.core\";\n\n              nativeImage.enable = true;\n              # customJdk.enable = true;\n            }\n          ];\n        };\n\n      };\n    });\n}\n</code></pre> <p>If you want to build an optimized JDK, instead of a native image, just turn on a flag :-)</p>"},{"location":"nix-module/#options","title":"Options","text":"<p>There are many more options: Full list of options</p> <p>Note</p> <p>If you want to build a binary from you clojure code, I recommended to use the Nix module. For more complex cases, you can use the functions <code>mkCljBin</code>, <code>customJdk</code> and <code>mkGraalBin</code> directly, but consider those a lower level API.</p> <p>Warning</p> <p>The clj-nix Nix module is still experimental and may still undergo breaking changes.</p> <p>More documentation about modules: NixOS modules</p>"},{"location":"options/","title":"Options","text":""},{"location":"options/#buildcommand","title":"buildCommand","text":"<p>Command to build the jar application. If not provided, a default builder is used</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#builder-extra-inputs","title":"builder-extra-inputs","text":"<p>Extra inputs to the default builder</p> <p>Type: list of package</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#builder-java-opts","title":"builder-java-opts","text":"<p>List of Java options to include in default builder command</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#builder-postbuild","title":"builder-postBuild","text":"<p>Post build commands for the default builder</p> <p>Type: string</p> <p>Default: <code>\"\"</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#builder-prebuild","title":"builder-preBuild","text":"<p>Pre build commands for the default builder</p> <p>Type: string</p> <p>Default: <code>\"\"</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#compilecljopts","title":"compileCljOpts","text":"<p>Override options passed to compile-clj</p> <p>Type: anything</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#customjdk","title":"customJdk","text":"<p>This option has no description.</p> <p>Type: submodule</p> <p>Default: <code>{ }</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#customjdkenable","title":"customJdk.enable","text":"<p>Creates a custom JDK runtime with <code>jlink</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#customjdkextrajdkmodules","title":"customJdk.extraJdkModules","text":"<p>Extra JDK modules appended to <code>jdkModules</code></p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#customjdkjdkmodules","title":"customJdk.jdkModules","text":"<p>Option passed to <code>jlink --add-modules</code>. If <code>null</code>, <code>jdeps</code> will be used to analyze the uberjar</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#customjdklocales","title":"customJdk.locales","text":"<p>Option passed to <code>jlink --include-locales</code></p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#java-opts","title":"java-opts","text":"<p>List of Java options to include in the application wrapper</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#javacopts","title":"javacOpts","text":"<p>Options passed to javac. Needed if the projects contains java source files</p> <p>Type: null or (submodule)</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#javacoptsjavac-opts","title":"javacOpts.javac-opts","text":"<p>This option has no description.</p> <p>Type: null or (list of string)</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#javacoptssrc-dirs","title":"javacOpts.src-dirs","text":"<p>This option has no description.</p> <p>Type: list of string</p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#jdk","title":"jdk","text":"<p>JDK used to build and run the application.</p> <p>Type: package</p> <p>Default: <code>pkgs.jdk_headless</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#lockfile","title":"lockfile","text":"<p>The lock file</p> <p>Type: null or path</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#main-ns","title":"main-ns","text":"<p>Main clojure namespace. A <code>-main</code> function is expected here. <code>main-ns</code> file must include the :gen-class directive, e.g.: <code>(ns foo (:gen-class))</code></p> <p>Type: string</p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#name","title":"name","text":"<p>Name of the clojure project. Needs to include the namespace.</p> <p>Type: string</p> <p>Example: <code>\"myorg/project\"</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimage","title":"nativeImage","text":"<p>This option has no description.</p> <p>Type: submodule</p> <p>Default: <code>{ }</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimageenable","title":"nativeImage.enable","text":"<p>Generates a binary with GraalVM</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimageextranativeimagebuildargs","title":"nativeImage.extraNativeImageBuildArgs","text":"<p>Extra arguments to be passed to the native-image command</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimagegraalvm","title":"nativeImage.graalvm","text":"<p>GraalVM used at build time</p> <p>Type: package</p> <p>Default: <code>pkgs.graalvm-ce</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimagegraalvmxmx","title":"nativeImage.graalvmXmx","text":"<p>XMX size of GraalVM during build</p> <p>Type: string</p> <p>Default: <code>\"-J-Xmx6g\"</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#nativeimagestatic","title":"nativeImage.static","text":"<p>Build a static binary using musl libc</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#projectsrc","title":"projectSrc","text":"<p>Project source code.</p> <p>Type: path</p> <p>Example: <code>./.</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#uberopts","title":"uberOpts","text":"<p>Options passed to uber.</p> <p>Type: null or (submodule)</p> <p>Default: <code>null</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#uberoptsexclude","title":"uberOpts.exclude","text":"<p>This option has no description.</p> <p>Type: list of string</p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#version","title":"version","text":"<p>Derivation and clojure project version</p> <p>Type: string</p> <p>Default: <code>\"DEV\"</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"options/#withleiningen","title":"withLeiningen","text":"<p>Enable it to invoke leiningen during the build</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:  - https://github.com/jlesquembre/clj-nix/blob/main/modules/top-level.nix</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial","title":"Tutorial","text":"<p>Source code for this tutorial can be found here: https://github.com/jlesquembre/clj-demo-project</p>"},{"location":"tutorial/#init","title":"Init","text":"<p>There is a template to help you start your new project:</p> <pre><code>nix flake new --template github:jlesquembre/clj-nix ./my-new-project\n</code></pre> <p>For this tutorial you can clone the final version:</p> <pre><code>git clone git@github.com:jlesquembre/clj-demo-project.git\n</code></pre> <p>First thing we need to do is to generate a lock file:</p> <pre><code>nix run github:jlesquembre/clj-nix#deps-lock\ngit add deps-lock.json\n</code></pre> <p>Note</p> <p>The following examples assume that you cloned the demo repository, and you are executing the commands from the root of the repository. But with Nix flakes, it's possible to point to the remote git repository. E.g.: We can replace <code>nix run .#foo</code> with <code>nix run github:/jlesquembre/clj-demo-project#foo</code></p>"},{"location":"tutorial/#create-a-binary-from-a-clojure-application","title":"Create a binary from a Clojure application","text":"<p>First, we create a new package in our flake:</p> <pre><code>clj-tuto = cljpkgs.mkCljBin {\n  projectSrc = ./.;\n  name = \"me.lafuente/cljdemo\";\n  main-ns = \"demo.core\";\n};\n</code></pre> <p>Let's try it:</p> <pre><code>nix build .#clj-tuto\n./result/bin/clj-tuto\n# Or\nnix run .#clj-tuto\n</code></pre> <p>Nice! We have a binary for our application. But how big is our app? We can find it with:</p> <pre><code>nix path-info -sSh .#clj-tuto\n# Or to see all the dependencies:\nnix path-info -rsSh .#clj-tuto\n</code></pre> <p>Um, the size of our application is <code>1.3G</code>, not ideal if we want to create a container. We can use a headless JDK to reduce the size, let's try that:</p> <pre><code>clj-tuto = cljpkgs.mkCljBin {\n  projectSrc = ./.;\n  name = \"me.lafuente/cljdemo\";\n  main-ns = \"demo.core\";\n  jdkRunner = pkgs.jdk17_headless;\n};\n</code></pre> <pre><code>nix build .#clj-tuto\nnix path-info -sSh .#clj-tuto\n</code></pre> <p>Good, now the size is <code>703.9M</code>. It's an improvement, but still big. To reduce the size, we can use the <code>customJdk</code> helper.</p>"},{"location":"tutorial/#create-custom-jdk-for-a-clojure-application","title":"Create custom JDK for a Clojure application","text":"<p>We add a package to our flake, to build a customized JDK for our Clojure application:</p> <pre><code>jdk-tuto = cljpkgs.customJdk {\n  cljDrv = self.packages.\"${system}\".clj-tuto;\n  locales = \"en,es\";\n};\n</code></pre> <pre><code>nix build .#jdk-tuto\nnix path-info -sSh .#jdk-tuto\n</code></pre> <p>Not bad! We reduced the size to <code>96.3M</code>. That's something we can put in a container. Let's create a container with our application.</p>"},{"location":"tutorial/#create-a-container","title":"Create a container","text":"<p>Again, we add a new package to our flake, in this case it will create a container:</p> <pre><code>clj-container =\n  pkgs.dockerTools.buildLayeredImage {\n    name = \"clj-nix\";\n    tag = \"latest\";\n    config = {\n      Cmd = clj-nix.lib.mkCljCli self.packages.\"${system}\".jdk-tuto { };\n    };\n  };\n</code></pre> <pre><code>nix build .#clj-container\nnix path-info -sSh .#clj-container\n</code></pre> <p>The container's size is <code>52.8M</code>. Wait, how can be smaller than our custom JDK derivation? There are 2 things to consider.</p> <p>First, notice that we used the <code>mkCljCli</code> helper function. In the original version, our binary is a bash script, so <code>bash</code> is a dependency. But in a container we don't need <code>bash</code>, the container runtime can launch the command, and we can reduce the size by removing <code>bash</code></p> <p>Second, notice that the image was compressed with gzip.</p> <p>Let's load and execute the image:</p> <pre><code>docker load &lt; result\ndocker run -it --rm clj-nix\ndocker images\n</code></pre> <p>Docker reports an image size of <code>99.2MB</code></p>"},{"location":"tutorial/#create-a-native-image-with-graalvm","title":"Create a native image with GraalVM","text":"<p>If we want to continue reducing the size of our derivation, we can compile the application with GraalVM. Keep in mind that size it's not the only factor to consider. There is a nice slide from the GraalVM team, illustrating what technology to use for which use case:</p> <p></p> <p>(The image was taken from a tweet by Thomas W\u00fcrthinger)</p> <p>For more details, see: Does GraalVM native image increase overall application performance or just reduce startup times?</p> <p>Let's compile our Clojure application with GraalVM:</p> <pre><code>graal-tuto = cljpkgs.mkGraalBin {\n  cljDrv = self.packages.\"${system}\".clj-tuto;\n};\n</code></pre> <pre><code>nix build .#graal-tuto\n./result/bin/clj-tuto\nnix path-info -sSh .#graal-tuto\n</code></pre> <p>The size is just <code>43.4M</code>.</p> <p>We can create a container from this derivation too:</p> <pre><code>graal-container =\n  let\n    graalDrv = self.packages.\"${system}\".graal-tuto;\n  in\n  pkgs.dockerTools.buildLayeredImage {\n    name = \"clj-graal-nix\";\n    tag = \"latest\";\n    config = {\n      Cmd = \"${graalDrv}/bin/${graalDrv.name}\";\n    };\n  };\n</code></pre> <pre><code>docker load &lt; result\ndocker run -it --rm clj-graal-nix\n</code></pre> <p>In this case, the container image size is <code>45.3MB</code>, aproximately half the size of the custom JDK image.</p>"},{"location":"usage/","title":"Quickstart","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>This project requires Nix Flakes</p>"},{"location":"usage/#new-project-template","title":"New project template","text":"<pre><code>nix flake new --template github:jlesquembre/clj-nix ./my-new-project\ncd ./my-new-project\ngit init\ngit add .\n\n# Build and test the binary\nnix build .\n./result/bin/cljdemo\n</code></pre> <p>Remember that with flakes, only the files tracked by git are recognized by Nix.</p> <p>Templates are for new projects. If you want to add <code>clj-nix</code> to an existing project, I suggest just copy the parts you need from the template (located here: clj-nix/templates/default)</p>"}]}